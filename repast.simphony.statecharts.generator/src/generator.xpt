«IMPORT scmodel»
«EXTENSION  generator_util»

«DEFINE Main FOR StateMachine-»
«init()»
«FILE filename()-»

package «this.package»;

import repast.simphony.statecharts.*;
import java.util.Map;
import java.util.HashMap;

public class «className» extends DefaultStateChart<«this.agentType»> {

    public static «className» createStateChart(«agentType» agent, double begin) {
        «className» result = createStateChart(agent);
        StateChartCombinedActionScheduler.INSTANCE.scheduleBeginTime(begin,result);
        return result;
    }

    public static «className» createStateChart(«agentType» agent) {
        «generatorClassName()» generator = new «generatorClassName()»();
        return generator.build(agent);
    }

    private «className»(«agentType» agent) {
        super(agent);
    }
    
    private static class MyStateChartBuilder extends StateChartBuilder<«agentType»> {

        public MyStateChartBuilder(«agentType» agent, AbstractState<«agentType»> entryState) {
            super(agent, entryState);
        }

        @Override
        public «className» build() {
            «className» result = new «className»(getAgent());
            setStateChartProperties(result);
            return result;
        }
    }


private static class «generatorClassName()» {

    private Map<String, AbstractState<«agentType»>> stateMap = new HashMap<String, AbstractState<«agentType»>>();

    public «className» build(«agentType» agent) {
        «IF this.states.size == 0-»
        throw new UnsupportedOperationException("Statechart has not been defined.");
        «ELSE-»
        «LET findFirstState(this.states) AS firstState -»
            «EXPAND blockContent(agentType) FOR firstState-»
            MyStateChartBuilder mscb = new MyStateChartBuilder(agent, «getVar(firstState)»);
            «EXPAND blockContent(agentType, "mscb.addRootState") FOREACH states.reject(e | e.uuid == firstState.uuid)-»
        «ENDLET-»
        createTransitions(mscb);
        return mscb.build();
        «ENDIF»
    }
    «EXPAND csBlock(agentType) FOREACH compositeStates(states)-»
   
   «LET transitions.reject(e| e.isValid()) AS links-»
    private void createTransitions(MyStateChartBuilder mscb) {
        «EXPAND transitionCreateCall FOREACH links» 
    }
    
   «EXPAND transitionCreateMethod FOREACH links» 
   «ENDLET»
}
}
«ENDFILE»

«EXPAND createActions(package.trim(), agentType.trim()) FOREACH states-»
«ENDDEFINE»

«REM» transitions «ENDREM»
«DEFINE transitionCreateCall FOR Transition-»
    // creates transition «this.id»
    «getTransitionMethodName(this.uuid)»(mscb);
«ENDDEFINE»

«DEFINE transitionCreateMethod FOR Transition-»
    // creates transition «this.id»
    private void «getTransitionMethodName(this.uuid)»(MyStateChartBuilder mscb) {
    
    }
«ENDDEFINE»


«REM» expansions for creating state actions «ENDREM»
«DEFINE createActionsCore(String package, String agentType) FOR AbstractState»
«IF this.onEnter != null && this.onEnter.trim().length > 0-»
    «EXPAND createAction(package.trim(), getOnEnterActionType(this.uuid), agentType.trim(), this.onEnter.trim()) FOR this-»
«ENDIF»

«IF this.onExit != null && this.onExit.trim().length > 0-»
    «EXPAND createAction(package.trim(), getOnExitActionType(this.uuid), agentType.trim(), this.onExit.trim()) FOR this-»
«ENDIF»
«ENDDEFINE»

«DEFINE createAction(String package, String actType, String agentType, String body) FOR AbstractState»
    «FILE actionFilename(package, actType)-»
	    package «package»;
	    
	    import repast.simphony.statecharts.*;
	    import repast.simphony.parameter.Parameters;
	    
	    import «getPackageFromType(agentType)».*;
	    
	    «LET getSimpleClassName(agentType) AS simpleType»
	    /**
	     * Action for «this.id».
	     */
	    public class «actType» implements StateAction<«simpleType»> {
	        @Override
	        public void action(«simpleType» agent, AbstractState<«simpleType»> state, Parameters params) throws Exception {
	            «body»
	        }
	    }
	    «ENDLET»
    «ENDFILE»
«ENDDEFINE»

«DEFINE createActions(String package, String agentType) FOR AbstractState-»
    «EXPAND createActionsCore(package, agentType) FOR this-»
«ENDDEFINE»

«DEFINE createActions(String package, String agentType) FOR CompositeState-»
    «EXPAND createActionsCore(package, agentType) FOR this-»
    «EXPAND createActions(package, agentType) FOREACH children-»
«ENDDEFINE»

«REM» expansions for create states «ENDREM»
«DEFINE registerActions(String agentType, String bvar) FOR AbstractState-»
        «IF this.onEnter != null && this.onEnter.trim().length > 0-»
            «bvar».registerOnEnter(new «getOnEnterActionType(this.uuid)»());
        «ENDIF-»
        «IF this.onExit != null && this.onExit.trim().length > 0-»
            «bvar».registerOnExit(new «getOnExitActionType(this.uuid)»());
        «ENDIF-»
«ENDDEFINE»

«DEFINE blockContent(String agentType) FOR AbstractState-»
«ENDDEFINE»

«DEFINE blockContent(String agentType, String addMethod) FOR PseudoState-»
    «IF this.type == PseudoStateTypes::choice»
        «LET getBranchVar(this.uuid) AS bvar-»
        BranchState<«agentType»> «bvar» = new BranchStateBuilder<«agentType»>("«this.id»").build();
        stateMap.put("«this.uuid»", «bvar»);
        «addMethod»(«bvar»);
        «ENDLET»
    «ENDIF»
«ENDDEFINE»

«DEFINE blockContent(String agentType, String addMethod) FOR AbstractState-»
    «EXPAND blockContent(agentType)-»
    «addMethod»(«getVar(this)»);
«ENDDEFINE»

«DEFINE blockContent(String agentType) FOR CompositeState-»
    // «this.id»
    CompositeState<«agentType»> «getVar(this)» = «getCSMethodName(this.uuid)»();
«ENDDEFINE»

«DEFINE blockContent(String agentType) FOR History-»
     «LET getSBVar(this.uuid) AS bvar-»
        HistoryStateBuilder<«agentType»> «bvar» = new HistoryStateBuilder<«agentType»>("«this.id»", «this.shallow»);
        «EXPAND registerActions(agentType, bvar) FOR this-»
        HistoryState<«agentType»> «getVar(this)» = «bvar».build();
        stateMap.put("«this.uuid»", «getVar(this)»);
     «ENDLET-»
«ENDDEFINE»

«DEFINE blockContent(String agentType) FOR State-»
     «LET getSBVar(this.uuid) AS bvar-»
        SimpleStateBuilder<«agentType»> «bvar» = new SimpleStateBuilder<«agentType»>("«this.id»");
        «EXPAND registerActions(agentType, bvar) FOR this-»
        SimpleState<«agentType»> «getVar(this)» = «bvar».build();
        stateMap.put("«this.uuid»", «getVar(this)»);
     «ENDLET-»
«ENDDEFINE»

«DEFINE blockContent(String agentType) FOR FinalState-»
     «LET getSBVar(this.uuid) AS bvar-»
        FinalStateBuilder<«agentType»> «bvar» = new FinalStateBuilder<«agentType»>("«this.id»");
        «EXPAND registerActions(agentType, bvar) FOR this-»
        FinalState<«agentType»> «getVar(this)» = «bvar».build();
        stateMap.put("«this.uuid»", «getVar(this)»);
     «ENDLET-»
«ENDDEFINE»

«DEFINE csBlock(String agentType) FOR CompositeState-»
    // Creates CompositeState '«this.id»'
    private CompositeState<«agentType»> «getCSMethodName(this.uuid)»() {
        «LET getCSBVar(this.uuid) AS csbVar»
            «LET findInitialState(this.children) AS initialState -»
                «EXPAND blockContent(agentType) FOR initialState-»
   
                CompositeStateBuilder<«agentType»> «csbVar» = new CompositeStateBuilder<«agentType»>("«this.id»", «getVar(initialState)»);
                «EXPAND registerActions(agentType, csbVar) FOR this-»
                «FOREACH children.reject(e | e.uuid == initialState.uuid) AS child»
                    «IF History.isInstance(child)-»
                         «EXPAND blockContent(agentType, csbVar + ".addHistoryState") FOR child-»
                     «ELSE»
                         «EXPAND blockContent(agentType, csbVar + ".addChildState") FOR child-»
                     «ENDIF»
                «ENDFOREACH»
               
            «ENDLET-»
            «LET getCSVar(this.uuid) AS csVar-»
                CompositeState<«agentType»> «csVar» = «csbVar».build();
                stateMap.put("«this.uuid»", «csVar»);
                return «csVar»;
            «ENDLET-»
        «ENDLET-»
  }
  
«EXPAND csBlock(agentType) FOREACH compositeStates(children)-»
«ENDDEFINE»



