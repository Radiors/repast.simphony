/*
 * Copyright (c) 2003, Alexander Greif All rights reserved. (Adapted by Michael
 * J. North for Use in Repast Simphony from Alexander Greif’s Flow4J-Eclipse
 * (http://flow4jeclipse.sourceforge.net/docs/index.html), with Thanks to the
 * Original Author) (Michael J. North’s Modifications are Copyright 2007 Under
 * the Repast Simphony License, All Rights Reserved)
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *  * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer. * Redistributions in
 * binary form must reproduce the above copyright notice, this list of
 * conditions and the following disclaimer in the documentation and/or other
 * materials provided with the distribution. * Neither the name of the
 * Flow4J-Eclipse project nor the names of its contributors may be used to
 * endorse or promote products derived from this software without specific prior
 * written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

package repast.simphony.agents.model.codegen;

import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import repast.simphony.agents.base.Util;

/**
 * Class JavaFile TODO
 * 
 * @author agreif (Adapted by Michael J. North for Use in Repast Simphony from
 *         Alexander Greif’s Flow4J-Eclipse
 *         (http://flow4jeclipse.sourceforge.net/docs/index.html), with Thanks
 *         to the Original Author)
 * 
 */
@SuppressWarnings("unchecked")
public class JavaFile extends DepthCounter implements ISrcStructure {

	private final String HEADER_COMMENT = "/**"
			+ Util.getPlatformLineDelimiter()
			+ " * "
			+ Util.getPlatformLineDelimiter()
			+ " * This file was automatically generated by the Repast Simphony Agent Editor."
			+ Util.getPlatformLineDelimiter()
			+ " * Please see http://repast.sourceforge.net/ for details."
			+ Util.getPlatformLineDelimiter() + " * "
			+ Util.getPlatformLineDelimiter() + " */"
			+ Util.getPlatformLineDelimiter() + Util.getPlatformLineDelimiter();

	/**
	 * the package name or null if the default package
	 */
	private String packageName;
	private List imports = new ArrayList();
	{
		addImport("java.io.*");
		addImport("java.math.*");
		addImport("java.util.*");
		addImport("javax.measure.unit.*");
		addImport("org.jscience.mathematics.number.*");
		addImport("org.jscience.mathematics.vector.*");
		addImport("org.jscience.physics.amount.*");
		addImport("repast.simphony.adaptation.neural.*");
		addImport("repast.simphony.adaptation.regression.*");
		addImport("repast.simphony.context.*");
		addImport("repast.simphony.context.space.continuous.*");
		addImport("repast.simphony.context.space.gis.*");
		addImport("repast.simphony.context.space.graph.*");
		addImport("repast.simphony.context.space.grid.*");
		addImport("repast.simphony.engine.environment.*");
		addImport("repast.simphony.engine.schedule.*");
		addImport("repast.simphony.engine.watcher.*");
		addImport("repast.simphony.groovy.math.*");
		addImport("repast.simphony.integration.*");
		addImport("repast.simphony.matlab.link.*");
		addImport("repast.simphony.query.*");
		addImport("repast.simphony.query.space.continuous.*");
		addImport("repast.simphony.query.space.gis.*");
		addImport("repast.simphony.query.space.graph.*");
		addImport("repast.simphony.query.space.grid.*");
		addImport("repast.simphony.query.space.projection.*");
		addImport("repast.simphony.parameter.*");
		addImport("repast.simphony.random.*");
		addImport("repast.simphony.space.continuous.*");
		addImport("repast.simphony.space.gis.*");
		addImport("repast.simphony.space.graph.*");
		addImport("repast.simphony.space.grid.*");
		addImport("repast.simphony.space.projection.*");
		addImport("repast.simphony.ui.probe.*");
		addImport("repast.simphony.util.*");
		addImport("simphony.util.messages.*");
		addImport("static java.lang.Math.*");
		addImport("static repast.simphony.essentials.RepastEssentials.*");

	}

	private JavaClass javaClass = new JavaClass();
	protected String headerComment = HEADER_COMMENT;

	/**
	 * TODO
	 * 
	 * @param packageName
	 */
	public void setPackageName(String packageName) {
		this.packageName = packageName;
	}

	/**
	 * TODO
	 * 
	 * @return
	 */
	public JavaClass getJavaClass() {
		return javaClass;
	}

	public void addImport(String importName) {
		imports.add(importName);
	}

	/**
	 * 
	 * Serializes the classes source code to the given Writer
	 * 
	 * @param sourceWriter
	 *            the writer where the contents should be serialized to
	 */
	public void serialize(Writer sourceWriter) throws IOException {
		// StringWriter stringWriter = new StringWriter();
		// BufferedWriter writer = new BufferedWriter(stringWriter);

		Writer writer = sourceWriter;

		if (DepthCounter.isGeneratingGroovy()) {
			writer.write(HEADER_COMMENT);
		}

		// package
		if (DepthCounter.isGeneratingGroovy()) {
			writer.write("/**");
			writer.write(Util.getPlatformLineDelimiter());
			writer.write(" *");
			writer.write(Util.getPlatformLineDelimiter());
			writer.write(" * Set the package name.");
			writer.write(Util.getPlatformLineDelimiter());
			writer.write(" *");
			writer.write(Util.getPlatformLineDelimiter());
			writer.write(" */");
			writer.write(Util.getPlatformLineDelimiter());
			if (packageName != null && packageName.trim().length() != 0) {
				writer.write("package " + packageName + "");
				writer.write(Util.getPlatformLineDelimiter());
			}
		} else {
			if (packageName != null && packageName.trim().length() != 0) {
				writer.write("The package name is \"" + packageName + "\".");
			}
		}
		writer.write(Util.getPlatformLineDelimiter());

		// imports
		if (DepthCounter.isGeneratingGroovy()) {
			writer.write("/**");
			writer.write(Util.getPlatformLineDelimiter());
			writer.write(" *");
			writer.write(Util.getPlatformLineDelimiter());
			writer.write(" * Import the needed packages.");
			writer.write(Util.getPlatformLineDelimiter());
			writer.write(" *");
			writer.write(Util.getPlatformLineDelimiter());
			writer.write(" */");
			writer.write(Util.getPlatformLineDelimiter());
			for (Iterator iter = imports.iterator(); iter.hasNext();) {
				writer.write("import " + (String) iter.next() + "");
				writer.write(Util.getPlatformLineDelimiter());
			}
		} else {
			writer.write("The following external code is referenced:<BLOCKQUOTE>");
			writer.write(Util.getPlatformLineDelimiter());
			for (Iterator iter = imports.iterator(); iter.hasNext();) {
				writer.write("<li>Components from " + (String) iter.next() + "</li>");
				writer.write(Util.getPlatformLineDelimiter());
			}
			writer.write("</BLOCKQUOTE><P>");
		}
		writer.write(Util.getPlatformLineDelimiter());

		javaClass.serialize(writer);
		// writer.close();

	}

}
